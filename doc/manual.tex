\documentclass{article}

\input{doc/version}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[a4paper,left=20mm,right=20mm]{geometry}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{listings}
\usepackage{natbib}

\renewcommand{\ttdefault}{pcr}

\begin{document}

\begin{titlepage}
\begin{center}

\Huge{libsupermesh Version \version~ Manual} \\[0.15\textheight]
\Large{Dr. Patrick E. Farrell, Dr. J. R. Maddison, \\ Mr. I. Panourgias}

\end{center}
\end{titlepage}

\tableofcontents

\section{Introduction}

libsupermesh is a Fortran library for serial and parallel mesh intersection, or
supermeshing \citep{farrell2009,farrell2009a}. libsupermesh specifically
includes components used in the local supermeshing approach described in
\citet{farrell2011}. Here, given two input finite element meshes, elements in
each mesh which intersect are identified, and a local mesh of their intersection
is generated.

\section{Building libsupermesh}

libsupermesh is built using CMake\footnote{\url{https://cmake.org/}}, for
example via:
\begin{lstlisting}[language=sh,frame=single]
cd [LIBSUPERMESH_SOURCE_PATH]/build
cmake [LIBSUPERMESH_SOURCE_PATH] \
  -DCMAKE_INSTALL_PREFIX=[LIBSUPERMESH_INSTALL_PATH]
make
make install
\end{lstlisting}
where \verb+[LIBSUPERMESH_SOURCE_PATH]+ is the path to the source directory, and
\linebreak \verb+[LIBSUPERMESH_INSTALL_PATH]+ is the path to the installation
directory. Note that libsupermesh cannot be built in the source directory.

\subsection*{CMake variables}

\begin{description}[font=\ttfamily\bfseries]
  \item[CMAKE\_BUILD\_TYPE] Build type. Valid options are ``Release'' and
    ``Debug''. Default ``Release''.
  \item[BUILD\_SHARED\_LIBS] Build a shared library. Default disabled. 
  \item[LIBSUPERMESH\_AUTO\_COMPILER\_FLAGS] Choose compiler flags
    automatically, enabling aggressive optimisation options for the Release
    build and additional debugging options for the Debug build. Active only if
    the GNU or Cray compilers are used. This overrides other CMake compiler flag
    variables. Default enabled.
  \item[LIBSUPERMESH\_ENABLE\_JUDY] Use the Judy library. Requires an available
    installation of Judy. Default disabled.
  \item[LIBSUPERMESH\_ENABLE\_TIMERS] Enable internal timers for parallel
    supermeshing. Default disabled.
  \item[LIBSUPERMESH\_OVERLAP\_COMPUTE\_COMMS] Overlaps communication and some
    calculation in parallel supermeshing. Default disabled.
\end{description}

\subsection*{Build targets}

\begin{description}[font=\ttfamily\bfseries]
  \item[make] Default build. Builds the library and unit tests.
  \item[make test] Runs the unit tests.
  \item[make doc] Builds this manual.
\end{description}

\section{Intersection identification}

libsupermesh includes a number of different algorithms for identifying candidate
pairs of elements, in two different meshes, which intersect. These algorithms
are all based upon a ``minimal bounding box'' intersection predicate. Hence the
different approaches are all guaranteed to return all pairs of elements which
have a non-trivial intersection\footnote{Except for numerical precision related
errors.}, but may additionally return pairs of elements which have zero
intersection.

\subsection{Global intersection finders}

The following intersection finders return an element-element graph which
associates with all elements in a mesh ``A'' candidate intersecting elements in
the mesh ``B''. The following definitions are used:
\begin{description}[leftmargin=\parindent,labelindent=\parindent]
  \item[$d$] Mesh A defines a subset $\Omega_A \subset \mathbb{R}^d$, and mesh B
    a subset $\Omega_B \subset \mathbb{R}^d$.
  \item[$l_A$] Number of nodes per element in mesh A.
  \item[$l_B$] Number of nodes per element in mesh B.
  \item[$V_A$] Number of nodes in mesh A.
  \item[$V_B$] Number of nodes in mesh B.
  \item[$E_A$] Number of elements in mesh A.
  \item[$E_B$] Number of elements in mesh B.
\end{description}

Element-node graphs are represented as $l_A \times E_A$ and
$l_B \times E_B$ integer arrays respectively. For example, if \verb+enlist_a+
stores the element-node graph for mesh A, then in the following:
\begin{lstlisting}[language=FORTRAN]
  integer, dimension(l_A, E_A) :: enlist_a
  integer, dimension(l_A) :: nodes_a
  
  ! ...

  nodes_a = enlist_a(:, ele_a)
\end{lstlisting}
\verb+nodes_a+ contains the indices of nodes in mesh A for element \verb+ele_a+.

Candidate intersection element-element graphs are stored either as a ragged
array or as a Compressed Sparse Row (CSR) sparsity pattern\footnote{See the
\href{http://docs.scipy.org/doc/scipy-0.15.1/reference/generated/scipy.sparse.csr_matrix.html}{SciPy documentation.}}.
For the ragged array variant:
\begin{lstlisting}[language=FORTRAN]
  type(intersections), dimension(E_A) :: map_ab
  integer :: n
  integer, dimension(:), pointer :: v
  
  ! ...

  n = map_ab(ele_a)%n
  v => map_ab(ele_a)%v
\end{lstlisting}
or for the CSR sparsity pattern variant:
\begin{lstlisting}[language=FORTRAN]
  integer, dimension(:), allocatable, target :: map_ab_indices
  integer, dimension(E_A + 1) :: map_ab_indptr
  integer :: n
  integer, dimension(:), pointer :: v
  
  ! ...

  n = map_ab_indptr(ele_a + 1) - map_ab_indptr(ele_a)
  v => map_ab_indices(map_ab_indptr(ele_a):map_ab_indptr(ele_a + 1) - 1)
\end{lstlisting}
\verb+n+ contains the number of candidate elements in mesh B which may intersect
with element \verb+ele_a+ of mesh A. \verb+v+ points at a vector of length
\verb+n+ containing the indices of elements in mesh B which may intersect with
element \verb+ele_a+ of mesh A.

\subsubsection{\texttt{sort\_intersection\_finder}}

An intersection finder for 1D meshes, based upon a combination of a merge sort
and a 1D advancing front.

\begin{lstlisting}[language=FORTRAN]
  interface sort_intersection_finder
    module procedure sort_intersection_finder_rank_1_intersections, &
      & sort_intersection_finder_rank_2_intersections, &
      & sort_intersection_finder_rank_1_csr_sparsity, &
      & sort_intersection_finder_rank_2_csr_sparsity
  end interface sort_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine sort_intersection_finder_rank_1_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab)
    real, dimension(:), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] Length $V_A$ vector. Mesh A node coordinates.
  \item[enlist\_a] $2 \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] Length $V_B$ vector. Mesh B node coordinates.
  \item[enlist\_b] $2 \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine sort_intersection_finder_rank_2_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $1 \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $2 \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $1 \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $2 \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine sort_intersection_finder_rank_1_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] Length $V_A$ vector. Mesh A node coordinates.
  \item[enlist\_a] $2 \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] Length $V_B$ vector. Mesh B node coordinates.
  \item[enlist\_b] $2 \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine sort_intersection_finder_rank_2_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $1 \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $2 \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $1 \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $2 \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length 
    $E_A + 1$.
\end{description}

\subsubsection{\texttt{quadtree\_intersection\_finder}}\label{sect:quadtree}

An intersection finder for 2D meshes, based upon a quadtree data structure. Each
interface accepts an optional \verb+max_size+ argument, which specifies the
maximum number of elements in a leaf node. This should be greater than the
maximum number of elements which can be found in a neighbourhood of an arbitrary
point. \verb+max_size+ defaults to the maximum of $256$, and the maximal
node-element graph degree, if not specified.

\begin{lstlisting}[language=FORTRAN]  
  interface quadtree_intersection_finder
    module procedure quadtree_intersection_finder_intersections, &
      & quadtree_intersection_finder_csr_sparsity
  end interface quadtree_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine quadtree_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab, max_size)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
    integer, optional, intent(in) :: max_size
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
  \item[max\_size] Maximum number of elements in a quadtree leaf node.
\end{description}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine quadtree_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr, max_size)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
    integer, optional, intent(in) :: max_size
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
  \item[max\_size] Maximum number of elements in a quadtree leaf node.
\end{description}

\subsubsection{\texttt{octtree\_intersection\_finder}}\label{sect:octtree}

An intersection finder for 3D meshes, based upon an octtree data structure. See
section \ref{sect:quadtree} for details regarding the optional \verb+max_size+
argument.

\begin{lstlisting}[language=FORTRAN]  
  interface octtree_intersection_finder
    module procedure octtree_intersection_finder_intersections, &
      & octtree_intersection_finder_csr_sparsity
  end interface octtree_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine octtree_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab, max_size)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
    integer, optional, intent(in) :: max_size
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
  \item[max\_size] Maximum number of elements in an octtree leaf node.
\end{description}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine octtree_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr, max_size)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
    integer, optional, intent(in) :: max_size
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
  \item[max\_size] Maximum number of elements in an octtree leaf node.
\end{description}

\subsubsection{\texttt{tree\_intersection\_finder}}

An intersection finder for 2D and 3D meshes, which uses either the
\verb+quadtree_intersection_finder+ (section \ref{sect:quadtree}) or
\verb+octree_intersection_finder+ (section \ref{sect:octtree}).

\begin{lstlisting}[language=FORTRAN]
  interface tree_intersection_finder
    module procedure tree_intersection_finder_intersections, &
      & tree_intersection_finder_csr_sparsity
  end interface tree_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine tree_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  subroutine tree_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
\end{description}

\subsubsection{\texttt{rtree\_intersection\_finder}}

An intersection finder for 2D and 3D meshes, using a libspatialindex 1.8.5
R${}^*$-tree\footnote{\url{https://libspatialindex.github.io/}}.

\begin{lstlisting}[language=FORTRAN]
  interface rtree_intersection_finder
    module procedure rtree_intersection_finder_intersections, &
      & rtree_intersection_finder_csr_sparsity
  end interface rtree_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine rtree_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab)
    real(kind = c_double), dimension(:, :), intent(in) :: positions_a
    integer(kind = c_int), dimension(:, :), intent(in) :: enlist_a
    real(kind = c_double), dimension(:, :), intent(in) :: positions_b
    integer(kind = c_int), dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  subroutine rtree_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
\end{description}

\subsubsection{\texttt{advancing\_front\_intersection\_finder}}

An intersection finder for meshes with simplex or cubic elements, using
the algorithm described in \citet{farrell2011}
\citep[see also][]{gander2009,gander2013}. The intersection finder is primarily
intended for the case where the meshes A and B cover the same domain. However
correct output is guaranteed if:
\begin{enumerate}
  \item Element $1$ of mesh A intersects with at least one element of mesh B.
  \item The elements of mesh B which intersect with any given element of mesh A
        define an element-element sub-graph of the mesh B element-element
        graph\footnote{Here element-element graphs are defined by elements
        sharing a common facet.}. All of these sub-graphs should be connected. 
\end{enumerate}

\begin{lstlisting}[language=FORTRAN]
  interface advancing_front_intersection_finder
    module procedure advancing_front_intersection_finder_intersections, &
      & advancing_front_intersection_finder_csr_sparsity
  end interface advancing_front_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine advancing_front_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  subroutine advancing_front_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
\end{description}

\bibliography{doc/bibliography}
\bibliographystyle{plainnat}

\end{document}
