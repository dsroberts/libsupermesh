\documentclass{article}

\input{doc/version}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[a4paper,left=20mm,right=20mm]{geometry}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{listings}
\usepackage{natbib}

\renewcommand{\ttdefault}{pcr}

\begin{document}

\begin{titlepage}
\begin{center}

\Huge{libsupermesh Version \version~ Manual} \\[0.15\textheight]
\Large{Dr. Patrick E. Farrell, Dr. J. R. Maddison, \\ Mr. I. Panourgias}

\end{center}
\end{titlepage}

\tableofcontents

\section{Introduction}

libsupermesh is a Fortran library for serial and parallel mesh intersection, or
supermeshing \citep{farrell2009,farrell2009a}. libsupermesh specifically
includes components used in the local supermeshing approach described in
\citet{farrell2011}. Here, given two input finite element meshes, elements in
each mesh which intersect are identified, and a local mesh of their intersection
is generated.

\section{Building libsupermesh}

libsupermesh is built using CMake\footnote{\url{https://cmake.org/}}, for
example via:
\begin{lstlisting}[language=sh,frame=single]
cd [LIBSUPERMESH_SOURCE_PATH]/build
cmake [LIBSUPERMESH_SOURCE_PATH] \
  -DCMAKE_INSTALL_PREFIX=[LIBSUPERMESH_INSTALL_PATH]
make
make install
\end{lstlisting}
where \verb+[LIBSUPERMESH_SOURCE_PATH]+ is the path to the source directory, and
\linebreak \verb+[LIBSUPERMESH_INSTALL_PATH]+ is the path to the installation
directory. Note that libsupermesh cannot be built in the source directory.

\subsection*{CMake variables}

\begin{description}[font=\ttfamily\bfseries]
  \item[CMAKE\_BUILD\_TYPE] Build type. Valid options are ``Release'' and
    ``Debug''. Default ``Release''.
  \item[BUILD\_SHARED\_LIBS] Build a shared library. Default disabled. 
  \item[LIBSUPERMESH\_AUTO\_COMPILER\_FLAGS] Choose compiler flags
    automatically, enabling aggressive optimisation options for the Release
    build and additional debugging options for the Debug build. Active only if
    the GNU or Cray compilers are used. This overrides other CMake compiler flag
    variables. Default enabled.
  \item[LIBSUPERMESH\_ENABLE\_JUDY] Use the Judy library. Requires an available
    installation of Judy. Default disabled.
  \item[LIBSUPERMESH\_ENABLE\_TIMERS] Enable internal timers for parallel
    supermeshing. Default disabled.
  \item[LIBSUPERMESH\_OVERLAP\_COMPUTE\_COMMS] Overlaps communication and some
    calculation in parallel supermeshing. Default disabled.
\end{description}

\subsection*{Build targets}

\begin{description}[font=\ttfamily\bfseries]
  \item[make] Default build. Builds the library and unit tests.
  \item[make test] Runs the unit tests.
  \item[make doc] Builds this manual.
\end{description}

\section{Intersection identification}

libsupermesh includes a number of different algorithms for identifying candidate
pairs of elements, in two different meshes, which intersect. These algorithms
are all based upon an ``axis aligned bounding box'' intersection predicate. Hence
the different approaches are all guaranteed to return all pairs of elements
which have a non-trivial intersection\footnote{Except for numerical precision
related errors.}, but may additionally return pairs of elements which have zero
intersection.

The following definitions are used:
\begin{description}[leftmargin=\parindent,labelindent=\parindent]
  \item[$d$] Mesh A defines a subset $\Omega_A \subset \mathbb{R}^d$, and mesh B
    a subset $\Omega_B \subset \mathbb{R}^d$.
  \item[$l_A$] Number of nodes per element in mesh A.
  \item[$l_B$] Number of nodes per element in mesh B.
  \item[$V_A$] Number of nodes in mesh A.
  \item[$V_B$] Number of nodes in mesh B.
  \item[$E_A$] Number of elements in mesh A.
  \item[$E_B$] Number of elements in mesh B.
\end{description}

Element-node graphs are represented as $l_A \times E_A$ and
$l_B \times E_B$ integer arrays respectively. For example, if \verb+enlist_a+
stores the element-node graph for mesh A, then in the following:
\begin{lstlisting}[language=FORTRAN]
  integer, dimension(l_A, E_A) :: enlist_a
  integer, dimension(l_A) :: nodes_a
  
  ! ...

  nodes_a = enlist_a(:, ele_a)
\end{lstlisting}
\verb+nodes_a+ contains the indices of nodes in mesh A for element \verb+ele_a+.

Candidate intersection element-element graphs are stored either as a ragged
array or as a Compressed Sparse Row (CSR) sparsity pattern\footnote{See the
\href{http://docs.scipy.org/doc/scipy-0.15.1/reference/generated/scipy.sparse.csr_matrix.html}{SciPy documentation.}}.
For the ragged array variant:
\begin{lstlisting}[language=FORTRAN]
  type(intersections), dimension(E_A) :: map_ab
  integer :: n
  integer, dimension(:), pointer :: v
  
  ! ...

  n = map_ab(ele_a)%n
  v => map_ab(ele_a)%v
\end{lstlisting}
or for the CSR sparsity pattern variant:
\begin{lstlisting}[language=FORTRAN]
  integer, dimension(:), allocatable, target :: map_ab_indices
  integer, dimension(E_A + 1) :: map_ab_indptr
  integer :: n
  integer, dimension(:), pointer :: v
  
  ! ...

  n = map_ab_indptr(ele_a + 1) - map_ab_indptr(ele_a)
  v => map_ab_indices(map_ab_indptr(ele_a):map_ab_indptr(ele_a + 1) - 1)
\end{lstlisting}
\verb+n+ contains the number of candidate elements in mesh B which may intersect
with element \verb+ele_a+ of mesh A. \verb+v+ points at a vector of length
\verb+n+ containing the indices of elements in mesh B which may intersect with
element \verb+ele_a+ of mesh A.

\subsection{Global intersection finding}

The following intersection finders return an element-element graph which
associates with all elements in a mesh ``A'' candidate intersecting elements in
the mesh ``B''. 

\subsubsection{\texttt{sort\_intersection\_finder}}

An intersection finder for 1D meshes, based upon a combination of a merge sort
and a 1D advancing front.

\begin{lstlisting}[language=FORTRAN]
  interface sort_intersection_finder
    module procedure sort_intersection_finder_rank_1_intersections, &
      & sort_intersection_finder_rank_2_intersections, &
      & sort_intersection_finder_rank_1_csr_sparsity, &
      & sort_intersection_finder_rank_2_csr_sparsity
  end interface sort_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine sort_intersection_finder_rank_1_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab)
    real, dimension(:), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] Length $V_A$ vector. Mesh A node coordinates.
  \item[enlist\_a] $2 \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] Length $V_B$ vector. Mesh B node coordinates.
  \item[enlist\_b] $2 \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine sort_intersection_finder_rank_2_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $1 \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $2 \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $1 \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $2 \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine sort_intersection_finder_rank_1_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] Length $V_A$ vector. Mesh A node coordinates.
  \item[enlist\_a] $2 \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] Length $V_B$ vector. Mesh B node coordinates.
  \item[enlist\_b] $2 \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine sort_intersection_finder_rank_2_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $1 \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $2 \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $1 \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $2 \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length 
    $E_A + 1$.
\end{description}

\subsubsection{\texttt{quadtree\_intersection\_finder}}\label{sect:quadtree_global}

An intersection finder for 2D meshes, based upon a quadtree data structure. Each
interface accepts an optional \verb+max_size+ argument, which specifies the
maximum number of elements in a leaf node. This should be greater than the
maximum number of elements which can be found in a neighbourhood of an arbitrary
point. \verb+max_size+ defaults to the maximum of $256$, and the maximal
node-element graph degree, if not specified.

\begin{lstlisting}[language=FORTRAN]  
  pure function max_nelist_degree(nnodes, enlist) result(max_degree)
    integer, intent(in) :: nnodes
    integer, dimension(:, :), intent(in) :: enlist
    integer :: max_degree
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[nnodes] $V_B$.
  \item[enlist] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[max\_degree] Maximal mesh B node-element graph degree.
\end{description}

\begin{lstlisting}[language=FORTRAN]  
  interface quadtree_intersection_finder
    module procedure quadtree_intersection_finder_intersections, &
      & quadtree_intersection_finder_csr_sparsity
  end interface quadtree_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine quadtree_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab, max_size)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
    integer, optional, intent(in) :: max_size
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
  \item[max\_size] Maximum number of elements in a quadtree leaf node.
\end{description}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine quadtree_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr, max_size)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
    integer, optional, intent(in) :: max_size
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
  \item[max\_size] Maximum number of elements in a quadtree leaf node.
\end{description}

\subsubsection{\texttt{octtree\_intersection\_finder}}\label{sect:octtree_global}

An intersection finder for 3D meshes, based upon an octtree data structure. See
section \ref{sect:quadtree_global} for details regarding the optional
\verb+max_size+ argument.

\begin{lstlisting}[language=FORTRAN]  
  interface octtree_intersection_finder
    module procedure octtree_intersection_finder_intersections, &
      & octtree_intersection_finder_csr_sparsity
  end interface octtree_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine octtree_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab, max_size)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
    integer, optional, intent(in) :: max_size
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
  \item[max\_size] Maximum number of elements in an octtree leaf node.
\end{description}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine octtree_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr, max_size)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
    integer, optional, intent(in) :: max_size
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
  \item[max\_size] Maximum number of elements in an octtree leaf node.
\end{description}

\subsubsection{\texttt{tree\_intersection\_finder}}

An intersection finder for 2D and 3D meshes, which uses either the
\verb+quadtree_intersection_finder+ (section \ref{sect:quadtree_global}) or
\verb+octtree_intersection_finder+ (section \ref{sect:octtree_global}).

\begin{lstlisting}[language=FORTRAN]
  interface tree_intersection_finder
    module procedure tree_intersection_finder_intersections, &
      & tree_intersection_finder_csr_sparsity
  end interface tree_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine tree_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  subroutine tree_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
\end{description}

\subsubsection{\texttt{rtree\_intersection\_finder}}

An intersection finder for 2D and 3D meshes, using a libspatialindex 1.8.5
R${}^*$-tree\footnote{\url{https://libspatialindex.github.io/}}.

\begin{lstlisting}[language=FORTRAN]
  interface rtree_intersection_finder
    module procedure rtree_intersection_finder_intersections, &
      & rtree_intersection_finder_csr_sparsity
  end interface rtree_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine rtree_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab)
    real(kind = c_double), dimension(:, :), intent(in) :: positions_a
    integer(kind = c_int), dimension(:, :), intent(in) :: enlist_a
    real(kind = c_double), dimension(:, :), intent(in) :: positions_b
    integer(kind = c_int), dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  subroutine rtree_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
\end{description}

\subsubsection{\texttt{advancing\_front\_intersection\_finder}}

An intersection finder for meshes with simplex or cubic elements, using
the algorithm described in \citet{farrell2011}
\citep[see also][]{gander2009,gander2013}. The intersection finder is primarily
intended for the case where the meshes A and B cover the same domain. However
correct output is guaranteed if:
\begin{enumerate}
  \item Element $1$ of mesh A intersects with at least one element of mesh B.
  \item The elements of mesh B which intersect with any given element of mesh A
        define an element-element sub-graph of the mesh B element-element
        graph\footnote{Here element-element graphs are defined by elements
        sharing a common facet.}. All of these sub-graphs should be connected. 
\end{enumerate}

\begin{lstlisting}[language=FORTRAN]
  interface advancing_front_intersection_finder
    module procedure advancing_front_intersection_finder_intersections, &
      & advancing_front_intersection_finder_csr_sparsity
  end interface advancing_front_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine advancing_front_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  subroutine advancing_front_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
\end{description}

\subsubsection{\texttt{brute\_force\_intersection\_finder}}

A basic brute force intersection finder with quadratic complexity.

\begin{lstlisting}[language=FORTRAN]
  interface brute_force_intersection_finder
    module procedure brute_force_intersection_finder_intersections, &
      & brute_force_intersection_finder_csr_sparsity
  end interface brute_force_intersection_finder
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine brute_force_intersection_finder_intersections( &
    & positions_a, enlist_a, positions_b, enlist_b, map_ab)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    type(intersections), dimension(:), intent(out) :: map_ab
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab] Length $E_A$ vector. Candidate intersection element-element
    graph.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  pure subroutine brute_force_intersection_finder_csr_sparsity( &
    & positions_a, enlist_a, positions_b, enlist_b, &
    & map_ab_indices, map_ab_indptr)
    real, dimension(:, :), intent(in) :: positions_a
    integer, dimension(:, :), intent(in) :: enlist_a
    real, dimension(:, :), intent(in) :: positions_b
    integer, dimension(:, :), intent(in) :: enlist_b
    integer, dimension(:), allocatable, intent(out) :: map_ab_indices
    integer, dimension(:), intent(out) :: map_ab_indptr
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[positions\_a] $d \times V_A$ array. Mesh A node coordinates.
  \item[enlist\_a] $l_A \times E_A$ array. Mesh A element-node graph.
  \item[positions\_b] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist\_b] $l_B \times E_B$ array. Mesh B element-node graph.
  \item[map\_ab\_indices, map\_ab\_indptr] CSR sparsity. Candidate intersection
    element-element graph. \linebreak \verb+map_ab_indices+ has length
    $E_A + 1$.
\end{description}

\subsection{Queryable tree intersection finding}

The following intersection finders use a given mesh B to construct a tree based
structure which can be queried, one mesh A element at a time, for intersecting
elements.

\subsubsection{\texttt{quadtree\_type}}\label{sect:quadtree_query}
  
An intersection finder for 2D meshes, based upon a quadtree data structure. See
section \ref{sect:quadtree_global} for details regarding the optional
\verb+max_size+ argument.

~\newline
Allocate a \verb+quadtree_type+, which can later be queried for intersecting
elements.

\begin{lstlisting}[language=FORTRAN]
  interface allocate
    module procedure allocate_quadtree
  end interface allocate
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine allocate_quadtree(quadtree, positions, enlist, max_size)
    type(quadtree_type), intent(out) :: quadtree
    real, dimension(:, :), intent(in) :: positions
    integer, dimension(:, :), intent(in) :: enlist
    integer, optional, intent(in) :: max_size 
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[quadtree] Quadtree data structure.
  \item[positions] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist] $l_A \times E_B$ array. Mesh B element-node graph.
  \item[max\_size] Maximum number of elements in a quadtree leaf node.
\end{description}

\noindent Query an allocated \verb+quadtree_type+ for intersecting elements.
  
\begin{lstlisting}[language=FORTRAN]
  interface query
    module procedure query_quadtree_allocatable, query_quadtree_pointer
  end interface query
\end{lstlisting}
    
\begin{lstlisting}[language=FORTRAN]
  subroutine query_quadtree_allocatable(quadtree, element_a, eles_b)
    type(quadtree_type), intent(inout) :: quadtree
    real, dimension(:, :), intent(in) :: element_a
    integer, dimension(:), allocatable, intent(out) :: eles_b
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine query_quadtree_pointer(quadtree, element_a, eles_b)
    type(quadtree_type), intent(inout) :: quadtree
    real, dimension(:, :), intent(in) :: element_a
    integer, dimension(:), pointer, intent(out) :: eles_b
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[quadtree] Quadtree data structure.
  \item[element\_a] $d \times l_A$ array. Node coordinates of a mesh A element.
  \item[eles\_b] Elements of mesh B whose axis aligned bounding boxes intersect
    with the axis aligned bounding box of the given mesh A element.
\end{description}

\noindent Deallocate a \verb+quadtree_type+.
  
\begin{lstlisting}[language=FORTRAN]
  interface deallocate
    module procedure deallocate_quadtree
  end interface deallocate
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine deallocate_quadtree(quadtree)
    type(quadtree_type), intent(inout) :: quadtree
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[quadtree] Quadtree data structure.
\end{description}

\subsubsection{\texttt{octtree\_type}}\label{sect:octtree_query}
  
An intersection finder for 3D meshes, based upon an octtree data structure. See
section \ref{sect:octtree_global} for details regarding the optional
\verb+max_size+ argument.

~\newline
Allocate an \verb+octtree_type+, which can later be queried for intersecting
elements.

\begin{lstlisting}[language=FORTRAN]
  interface allocate
    module procedure allocate_octtree
  end interface allocate
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine allocate_octtree(octtree, positions, enlist, max_size)
    type(octtree_type), intent(out) :: octtree
    real, dimension(:, :), intent(in) :: positions
    integer, dimension(:, :), intent(in) :: enlist
    integer, optional, intent(in) :: max_size 
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[octtree] Octtree data structure.
  \item[positions] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist] $l_A \times E_B$ array. Mesh B element-node graph.
  \item[max\_size] Maximum number of elements in an octtree leaf node.
\end{description}

\noindent Query an allocated \verb+octtree_type+ for intersecting elements.
  
\begin{lstlisting}[language=FORTRAN]
  interface query
    module procedure query_octtree_allocatable, query_octtree_pointer
  end interface query
\end{lstlisting}
    
\begin{lstlisting}[language=FORTRAN]
  subroutine query_octtree_allocatable(octtree, element_a, eles_b)
    type(octtree_type), intent(inout) :: octtree
    real, dimension(:, :), intent(in) :: element_a
    integer, dimension(:), allocatable, intent(out) :: eles_b
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine query_octtree_pointer(octtree, element_a, eles_b)
    type(octtree_type), intent(inout) :: octtree
    real, dimension(:, :), intent(in) :: element_a
    integer, dimension(:), pointer, intent(out) :: eles_b
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[octtree] Octtree data structure.
  \item[element\_a] $d \times l_A$ array. Node coordinates of a mesh A element.
  \item[eles\_b] Elements of mesh B whose axis aligned bounding boxes intersect
    with the axis aligned bounding box of the given mesh A element.
\end{description}

\noindent Deallocate an \verb+octtree_type+.
  
\begin{lstlisting}[language=FORTRAN]
  interface deallocate
    module procedure deallocate_octtree
  end interface deallocate
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine deallocate_octtree(octtree)
    type(octtree_type), intent(inout) :: octtree
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[octtree] Octtree data structure.
\end{description}

\subsubsection{\texttt{tree\_type}}

An intersection finder for 2D and 3D meshes, which uses either the
\verb+quadtree_type+ (section \ref{sect:quadtree_query}) or \verb+octtree_type+
(section \ref{sect:octtree_query}).

~\newline
Allocate a \verb+tree_type+, which can later be queried for intersecting
elements.

\begin{lstlisting}[language=FORTRAN]
  interface allocate
    module procedure allocate_tree
  end interface allocate
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine allocate_tree(tree, positions, enlist)
    type(tree_type), intent(out) :: tree
    real, dimension(:, :), intent(in) :: positions
    integer, dimension(:, :), intent(in) :: enlist
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tree] Quadtree or octtree data structure.
  \item[positions] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist] $l_A \times E_B$ array. Mesh B element-node graph.
\end{description}

\noindent Query an allocated \verb+tree_type+ for intersecting elements.
  
\begin{lstlisting}[language=FORTRAN]
  interface query
    module procedure query_tree_allocatable, query_tree_pointer
  end interface query
\end{lstlisting}
    
\begin{lstlisting}[language=FORTRAN]  
  subroutine query_tree_allocatable(tree, element_a, eles_b)
    type(tree_type), intent(inout) :: tree
    real, dimension(:, :), intent(in) :: element_a
    integer, dimension(:), allocatable, intent(out) :: eles_b
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]  
  subroutine query_tree_pointer(tree, element_a, eles_b)
    type(tree_type), intent(inout) :: tree
    real, dimension(:, :), intent(in) :: element_a
    integer, dimension(:), pointer, intent(out) :: eles_b
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tree] Quadtree or octtree data structure.
  \item[element\_a] $d \times l_A$ array. Node coordinates of a mesh A element.
  \item[eles\_b] Elements of mesh B whose axis aligned bounding boxes intersect
    with the axis aligned bounding box of the given mesh A element.
\end{description}

\noindent Deallocate a \verb+tree_type+.
  
\begin{lstlisting}[language=FORTRAN]
  interface deallocate
    module procedure deallocate_tree
  end interface deallocate
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]  
  subroutine deallocate_tree(tree)
    type(tree_type), intent(inout) :: tree
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tree] Quadtree or octtree data structure.
\end{description}

\subsubsection{\texttt{rtree\_type}}

An intersection finder for 2D and 3D meshes, using a libspatialindex 1.8.5
R${}^*$-tree\footnote{\url{https://libspatialindex.github.io/}}.

~\newline
Allocate an \verb+rtree_type+, which can later be queried for intersecting
elements.

\begin{lstlisting}[language=FORTRAN]
  interface allocate
    module procedure allocate_rtree
  end interface allocate
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]  
  subroutine allocate_rtree(rtree, positions, enlist)
    type(rtree_type), intent(out) :: rtree
    real(kind = c_double), dimension(:, :), intent(in) :: positions
    integer(kind = c_int), dimension(:, :), intent(in) :: enlist
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[rtree] libspatialindex R${}^*$-tree data structure.
  \item[positions] $d \times V_B$ array. Mesh B node coordinates.
  \item[enlist] $l_A \times E_B$ array. Mesh B element-node graph.
\end{description}

\noindent Query an allocated \verb+rtree_type+ for intersecting elements.
  
\begin{lstlisting}[language=FORTRAN]
  interface query
    module procedure query_rtree_allocatable, query_rtree_pointer
  end interface query
\end{lstlisting}
    
\begin{lstlisting}[language=FORTRAN]    
  subroutine query_rtree_allocatable(rtree, element_a, eles_b)
    type(rtree_type), intent(inout) :: rtree
    real(kind = c_double), dimension(:, :), intent(in) :: element_a
    integer(kind = c_int), dimension(:), allocatable, intent(out) :: eles_b
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]      
  subroutine query_rtree_pointer(rtree, element_a, eles_b)
    type(rtree_type), intent(inout) :: rtree
    real(kind = c_double), dimension(:, :), intent(in) :: element_a
    integer(kind = c_int), dimension(:), pointer, intent(out) :: eles_b
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[rtree] libspatialindex R${}^*$-tree data structure.
  \item[element\_a] $d \times l_A$ array. Node coordinates of a mesh A element.
  \item[eles\_b] Elements of mesh B whose axis aligned bounding boxes intersect
    with the axis aligned bounding box of the given mesh A element.
\end{description}

\noindent Deallocate an \verb+rtree_type+.
  
\begin{lstlisting}[language=FORTRAN]
  interface deallocate
    module procedure deallocate_rtree
  end interface deallocate
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]  
  subroutine deallocate_rtree(rtree)
    type(rtree_type), intent(inout) :: rtree
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[rtree] libspatialindex R${}^*$-tree data structure.
\end{description}

\section{Element intersection}

Given two elements, element A from mesh A and element B from mesh B, the
following routines are used to construct a simplicial mesh ``C'', which is a
mesh of their intersection (the ``local supermesh'').

The following definitions are used:
\begin{description}[leftmargin=\parindent,labelindent=\parindent]
  \item[$d$] Mesh A defines a subset $\Omega_A \subset \mathbb{R}^d$, and mesh B
    a subset $\Omega_B \subset \mathbb{R}^d$.
  \item[$l$] Number of nodes in an element.
  \item[$l_A$] Number of nodes in element A.
  \item[$l_B$] Number of nodes in element B.
  \item[$F_A$] Number of element A facets.
  \item[$F_B$] Number of element B facets.
  \item[$l_C$] Number of nodes per element in the intersection mesh C, always
               equal to $d + 1$.
  \item[$E_C$] Number of elements in the intersection mesh C.
  \item[$M_C$] An upper bound for the maximum number of elements which can be
               in any intersection mesh C.
\end{description}

\subsection{Interval-interval}

Definition of $M_C$.
  
\begin{lstlisting}[language=FORTRAN] 
  integer, parameter :: interval_buf_size = 1
\end{lstlisting}

~\newline
Interval intersection.
  
\begin{lstlisting}[language=FORTRAN]    
  interface intersect_intervals
    module procedure intersect_intervals_rank_1, intersect_intervals_rank_2, &
      & intersect_intervals_rank_3
  end interface intersect_intervals
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]   
  pure subroutine intersect_intervals_rank_1(interval_a, interval_b, &
    & intervals_c, n_intervals_c)
    real, dimension(2), intent(in) :: interval_a
    real, dimension(2), intent(in) :: interval_b
    real, dimension(2), intent(out) :: intervals_c
    integer, intent(out) :: n_intervals_c
\end{lstlisting} 

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[interval\_a] Length $2$ vector. Element A node coordinates.
  \item[interval\_b] Length $2$ vector. Element B node coordinates.
  \item[interval\_c] Length $2$ vector. Intersection mesh C node coordinates.
  \item[n\_intervals\_c] Number of elements in mesh C. Equal to $1$ if elements
    A and B intersect, and $0$ otherwise.
\end{description}
  
\begin{lstlisting}[language=FORTRAN]   
  pure subroutine intersect_intervals_rank_2(interval_a, interval_b, &
    & intervals_c, n_intervals_c)
    real, dimension(2), intent(in) :: interval_a
    real, dimension(2), intent(in) :: interval_b
    real, dimension(2, interval_buf_size), intent(out) :: intervals_c
    integer, intent(out) :: n_intervals_c
\end{lstlisting} 

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[interval\_a] Length $2$ vector. Element A node coordinates.
  \item[interval\_b] Length $2$ vector. Element B node coordinates.
  \item[interval\_c] $2 \times M_C$ array. Intersection mesh C node coordinates.
  \item[n\_intervals\_c] Number of elements in mesh C. Equal to $1$ if elements
    A and B intersect, and $0$ otherwise.
\end{description}
  
\begin{lstlisting}[language=FORTRAN]  
  pure subroutine intersect_intervals_rank_3(interval_a, interval_b, &
    & intervals_c, n_intervals_c)
    real, dimension(1, 2), intent(in) :: interval_a
    real, dimension(1, 2), intent(in) :: interval_b
    real, dimension(1, 2, interval_buf_size), intent(out) :: intervals_c
    integer, intent(out) :: n_intervals_c
\end{lstlisting} 

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[interval\_a] $1 \times 2$ array. Element A node coordinates.
  \item[interval\_b] $1 \times 2$ vector. Element B node coordinates.
  \item[interval\_c] $1 \times 2 \times M_C$ array. Intersection mesh C node
    coordinates.
  \item[n\_intervals\_c] Number of elements in mesh C. Equal to $1$ if elements
    A and B intersect, and $0$ otherwise.
\end{description}

\noindent Interval length.
  
\begin{lstlisting}[language=FORTRAN]  
  interface interval_size
    module procedure interval_size_rank_1, interval_size_rank_2
  end interface interval_size
\end{lstlisting} 
  
\begin{lstlisting}[language=FORTRAN]  
  pure function interval_size_rank_1(interval) result(size)
    real, dimension(2), intent(in) :: interval
    real :: size
\end{lstlisting} 

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[interval] Length $2$ vector. Element node coordinates.
  \item[size] Length of the element.
\end{description}
  
\begin{lstlisting}[language=FORTRAN]    
  pure function interval_size_rank_2(interval) result(size)
    real, dimension(1, 2), intent(in) :: interval
    real :: size
\end{lstlisting} 

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[interval] $1 \times 2$ array. Element node coordinates.
  \item[size] Length of the element.
\end{description}

\subsection{Polygon-polygon}

Intersection of two-dimensional convex polygons using the \citet{sutherland1974}
algorithm.

~\newline
\verb+triangle_type+ data type, used to define triangles.

\begin{lstlisting}[language=FORTRAN]    
  type tri_type
    real, dimension(2, 3) :: v
  end type tri_type
\end{lstlisting} 

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[v] $d \times l$ array. Triangle node coordinates.
\end{description}

\noindent \verb+line_type+ data type, used to define the lines which constitute
element facets.

\begin{lstlisting}[language=FORTRAN]   
  type line_type
    real, dimension(2) :: normal
    real, dimension(2) :: point
  end type line_type
\end{lstlisting} 

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[normal] Length $d$ vector. Components of a vector normal to the line.
    Need not have unit norm.
  \item[point] Length $d$ vector. Coordinates of a point on the line.
\end{description}

\noindent Definition of $M_C$ for triangle-triangle intersection.
  
\begin{lstlisting}[language=FORTRAN] 
  integer, parameter :: tri_buf_size = 22
\end{lstlisting}

\noindent Definition of $M_C$ for triangle-polygon intersection.
  
\begin{lstlisting}[language=FORTRAN]
  interface max_n_tris_c
    module procedure max_n_tris_c_tri
  end interface max_n_tris_c
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  pure function max_n_tris_c_tri(n_lines_b) result(max_n_tris_c)
    integer, intent(in) :: n_lines_b
    integer :: max_n_tris_c
\end{lstlisting} 

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[n\_lines\_b] $F_B$, assuming that element A is a triangle.
  \item[max\_n\_tris\_c] $M_C = 3 \left( 2^{F_B} \right) - 2$.
\end{description}

\noindent Definition of $M_C$ for polygon-polygon intersection.

\begin{lstlisting}[language=FORTRAN]
  interface max_n_tris_c
    module procedure max_n_tris_c_poly
  end interface max_n_tris_c
\end{lstlisting} 

\begin{lstlisting}[language=FORTRAN]
  pure function max_n_tris_c_poly(n_lines_a, n_lines_b) result(max_n_tris_c)
    integer, intent(in) :: n_lines_a
    integer, intent(in) :: n_lines_b
    integer :: max_n_tris_c
\end{lstlisting} 

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[n\_lines\_a] $F_A$.
  \item[n\_lines\_b] $F_B$.
  \item[max\_n\_tris\_c] $M_C = F_A \left( 2^{F_B} \right) - 2$.
\end{description}

\noindent \verb+line_type+ representation of facets.

\begin{lstlisting}[language=FORTRAN]
  interface get_lines
    module procedure get_lines_tri, get_lines_poly
  end interface get_lines
\end{lstlisting} 

\begin{lstlisting}[language=FORTRAN]
  pure function get_lines_tri(tri) result(lines)
    type(tri_type), intent(in) :: tri
    type(line_type), dimension(3) :: lines
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tri] A triangle.
  \item[lines] The three facets of the triangle.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  pure function get_lines_poly(poly) result(lines)
    real, dimension(:, :), intent(in) :: poly    
    type(line_type), dimension(size(poly, 2)) :: lines
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[poly] $d \times l$ array. Coordinates of the polygon nodes, in either
    clockwise or anti-clockwise order.
  \item[lines] Length $l$ array. The facets of the polygon.
\end{description}

\noindent Triangle-triangle intersection.

\begin{lstlisting}[language=FORTRAN]
  interface intersect_tris
    module procedure intersect_tris_real, intersect_tris_tri
  end interface intersect_tris
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine intersect_tris_real(tri_a, tri_b, tris_c, n_tris_c)
    real, dimension(2, 3), intent(in) :: tri_a
    real, dimension(2, 3), intent(in) :: tri_b
    real, dimension(2, 3, tri_buf_size), intent(out) :: tris_c
    integer, intent(out) :: n_tris_c
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tri\_a] $d \times l_A$ array. Element A node coordinates. Element A
    must be a triangle.
  \item[tri\_b] $d \times l_B$ array. Element B node coordinates. Element B
    must be a triangle.
  \item[tris\_c] $d \times l_C \times M_C$ array. Mesh C node coordinates.
  \item[n\_tris\_c] $E_C$.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  subroutine intersect_tris_tri(tri_a, tri_b, tris_c, n_tris_c)
    type(tri_type), intent(in) :: tri_a
    type(tri_type), intent(in) :: tri_b
    type(tri_type), dimension(tri_buf_size), intent(out) :: tris_c
    integer, intent(out) :: n_tris_c
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tri\_a] Element A.
  \item[tri\_b] Element B.
  \item[tris\_c] Length $M_C$ vector. Triangles in mesh C.
  \item[n\_tris\_c] $E_C$.
\end{description}

\noindent Triangle-quadrilateral intersection.

\begin{lstlisting}[language=FORTRAN]
  subroutine intersect_tri_quad(tri_a, quad_b, tris_c, n_tris_c)
    real, dimension(:, :), intent(in) :: tri_a
    real, dimension(:, :), intent(in) :: quad_b
    real, dimension(:, :, :), intent(inout) :: tris_c
    integer, intent(out) :: n_tris_c
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tri\_a] $d \times l_A$ array. Element A node coordinates. Element A
    must be a triangle.
  \item[quad\_b] $d \times l_B$ array. Element B node coordinates. Element B
    must be a quadrilateral with the node coordinates in either clockwise or
    anti-clockwise order.
  \item[tris\_c] $d \times l_C \times M_C$ array. Mesh C node coordinates.
  \item[n\_tris\_c] $E_C$.
\end{description}

\noindent Quadrilateral-quadrilateral intersection.

\begin{lstlisting}[language=FORTRAN]
  subroutine intersect_quads(quad_a, quad_b, tris_c, n_tris_c)
    real, dimension(:, :), intent(in) :: quad_a
    real, dimension(:, :), intent(in) :: quad_b
    real, dimension(:, :, :), intent(inout) :: tris_c
    integer, intent(out) :: n_tris_c
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[quad\_a] $d \times l_A$ array. Element A node coordinates. Element A
    must be a quadrilateral with the node coordinates in either clockwise or
    anti-clockwise order.
  \item[quad\_b] $d \times l_B$ array. Element B node coordinates. Element B
    must be a quadrilateral with the node coordinates in either clockwise or
    anti-clockwise order.
  \item[tris\_c] $d \times l_C \times M_C$ array. Mesh C node coordinates.
  \item[n\_tris\_c] $E_C$.
\end{description}

\noindent Triangle-polygon intersection.
  
\begin{lstlisting}[language=FORTRAN]
  interface intersect_polys
    module procedure intersect_tri_lines
  end interface intersect_polys
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  subroutine intersect_tri_lines(tri_a, lines_b, tris_c, n_tris_c, area_b, work)
    type(tri_type), intent(in) :: tri_a
    type(line_type), dimension(:), intent(in) :: lines_b
    type(tri_type), dimension(:), intent(out) :: tris_c
    integer, intent(out) :: n_tris_c
    real, optional, intent(in) :: area_b
    real, dimension(:, :, :), target, optional, intent(out) :: work
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tri\_a] Element A.
  \item[lines\_b] Element B facets.
  \item[tris\_c] Length $M_C$ vector. Triangles in mesh C.
  \item[n\_tris\_c] $E_C$.
  \item[area\_b] Area of element B. Use to discard near degenerate elements in
    mesh C.
  \item[work] $2 \times M_C$ array. Working memory.
\end{description}

\noindent Polygon-polygon intersection.
  
\begin{lstlisting}[language=FORTRAN]
  interface intersect_polys
    module procedure intersect_polys_real, intersect_polys_lines
  end interface intersect_polys
\end{lstlisting}
  
\begin{lstlisting}[language=FORTRAN]
  subroutine intersect_polys_real(poly_a, poly_b, tris_c, n_tris_c, &
    & area_a, area_b, work)
    real, dimension(:, :), intent(in) :: poly_a
    real, dimension(:, :), intent(in) :: poly_b
    type(tri_type), dimension(:), intent(out) :: tris_c
    integer, intent(out) :: n_tris_c
    real, optional, intent(in) :: area_a
    real, optional, intent(in) :: area_b
    real, dimension(:, :, :), target, optional, intent(out) :: work
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[poly\_a] $d \times l_A$ array. Element A node coordinates. The node
    coordinates must be in either clockwise or anti-clockwise order.
  \item[poly\_b] $d \times l_B$ array. Element B node coordinates. The node
    coordinates must be in either clockwise or anti-clockwise order.
  \item[tris\_c] Length $M_C$ vector. Triangles in mesh C.
  \item[n\_tris\_c] $E_C$.
  \item[area\_a] Area of element A. Use to discard near degenerate elements in
    mesh C.
  \item[area\_b] Area of element B. Use to discard near degenerate elements in
    mesh C.
  \item[work] $2 \times M_C$ array. Working memory.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  subroutine intersect_polys_lines(poly_a, lines_b, tris_c, n_tris_c, &
    & area_a, area_b, work)
    real, dimension(:, :), intent(in) :: poly_a
    type(line_type), dimension(:), intent(in) :: lines_b
    type(tri_type), dimension(:), intent(out) :: tris_c
    integer, intent(out) :: n_tris_c
    real, optional, intent(in) :: area_a
    real, optional, intent(in) :: area_b
    real, dimension(:, :, :), target, optional, intent(out) :: work
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[poly\_a] $d \times l_A$ array. Element A node coordinates. The node
    coordinates must be in either clockwise or anti-clockwise order.
  \item[lines\_b] $d \times l_B$ array. Element B facets.
  \item[tris\_c] Length $M_C$ vector. Triangles in mesh C.
  \item[n\_tris\_c] $E_C$.
  \item[area\_a] Area of element A. Use to discard near degenerate elements in
    mesh C.
  \item[area\_b] Area of element B. Use to discard near degenerate elements in
    mesh C.
  \item[work] $2 \times M_C$ array. Working memory.
\end{description}

\noindent Triangle area.

\begin{lstlisting}[language=FORTRAN]
  interface triangle_area
    module procedure triangle_area_real, triangle_area_tri
  end interface triangle_area
\end{lstlisting}

\begin{lstlisting}[language=FORTRAN]
  pure function triangle_area_real(tri) result(area)
    real, dimension(2, 3), intent(in) :: tri
    real :: area
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tri] $d \times l$ array. Triangle node coordinates.
  \item[area] Area of the triangle.
\end{description}

\begin{lstlisting}[language=FORTRAN]
  pure function triangle_area_tri(tri) result(area)
    type(tri_type), intent(in) :: tri
    real :: area
\end{lstlisting}

\begin{description}[font=\ttfamily\bfseries,leftmargin=2.2\parindent,labelindent=1.7\parindent,noitemsep]
  \item[tri] A triangle.
  \item[area] Area of the triangle.
\end{description}

\bibliography{doc/bibliography}
\bibliographystyle{plainnat}

\end{document}
