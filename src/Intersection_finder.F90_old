!#define COUNT_INTERSECTION_TESTS
!#include "fdebug.h"

module libsupermesh_intersection_finder_module

!use quadrature
!use elements
!use fields_base
!use fields_data_types
!use fields_allocates
!use adjacency_lists
!use linked_lists
!use parallel_fields
!use parallel_tools
!use supermesh_construction
!use transform_elements
!use data_structures


implicit none

private

public libsupermesh_advancing_front_intersection_finder

contains

  function libsupermesh_advancing_front_intersection_finder(positionsA, positionsB, seed) result(map_AB)
    ! The positions and meshes of A and B
    type(vector_field), intent(in), target :: positionsA, positionsB
    ! for each element in A, the intersecting elements in B
    type(ilist), dimension(ele_count(positionsA)) :: map_AB
    integer, optional, intent(in) :: seed

    ! processed_neighbour maps an element to a neighbour that has already been processed (i.e. its clue)
    type(integer_hash_table) :: processed_neighbour
    ! we also need to keep a set of the elements we've seen: this is different to
    ! the elements that have map_AB(ele)%length > 0 in the case where the domain
    ! is not simply connected!
    type(integer_set) :: seen_elements

    integer :: ele_A
    type(mesh_type), pointer :: mesh_A, mesh_B
    integer :: i, neighbour
    real, dimension(ele_count(positionsB), positionsB%dim, 2) :: bboxes_B
    integer, dimension(:), pointer :: neigh_A
    type(csr_sparsity), pointer :: eelist_A, eelist_B

    type(ilist) :: clues

    ewrite(1, *) "In advancing_front_intersection_finder"
      
    mesh_A => positionsA%mesh
    mesh_B => positionsB%mesh

    eelist_A => extract_eelist(mesh_A)
    eelist_B => extract_eelist(mesh_B)

    call compute_bboxes(positionsB, bboxes_B)

    if(present(seed)) then
      assert(seed > 0)
      assert(seed <= ele_count(positionsA))
      ele_A = seed
    else
      ele_A = 1
    end if
    map_AB(ele_A) = brute_force_search(ele_val(positionsA, ele_A), positionsB, bboxes_B)

    call allocate(processed_neighbour)
    call allocate(seen_elements)

    neigh_A => row_m_ptr(eelist_A, ele_A)
    do i=1,size(neigh_A)
      neighbour = neigh_A(i)
      if (neighbour <= 0) cycle
      call insert(processed_neighbour, neighbour, ele_A)
    end do
    call insert(seen_elements, ele_A)

    do while (key_count(processed_neighbour) > 0)
      call fetch_pair(processed_neighbour, 1, ele_A, neighbour)
      ! try to keep our memory footprint low
      call remove(processed_neighbour, ele_A)
      call insert(seen_elements, ele_A)

      assert(map_AB(ele_A)%length == 0) ! we haven't seen it yet

      clues = clueful_search(ele_val(positionsA, ele_A), map_AB(neighbour), &
                           & bboxes_B, ele_A, neighbour)
      map_AB(ele_A) = advance_front(ele_val(positionsA, ele_A), positionsB, clues, bboxes_B, eelist_B)
      call deallocate(clues)

      ! Now that ele_A has been computed, make its clues available to anyone who needs them
      neigh_A => row_m_ptr(eelist_A, ele_A)
      do i=1,size(neigh_A)
        neighbour = neigh_A(i)
        if (neighbour <= 0) cycle
        if (has_value(seen_elements, neighbour)) then
          ! We've already seen it
          cycle
        end if
        call insert(processed_neighbour, neighbour, ele_A)
      end do
    end do

    assert(key_count(processed_neighbour) == 0)
    call deallocate(processed_neighbour)
    call deallocate(seen_elements)

    ewrite(1, *) "Exiting advancing_front_intersection_finder"

    contains
      function advance_front(posA, positionsB, clues, bboxes_B, eelist_B) result(map)
        real, dimension(:, :), intent(in) :: posA
        type(vector_field), intent(in), target :: positionsB
        type(ilist), intent(inout) :: clues
        real, dimension(:, :, :), intent(in) :: bboxes_B
        type(csr_sparsity), intent(in) :: eelist_B

        type(ilist) :: map
        integer, dimension(:), pointer :: neigh_B
        integer :: i, possible, neighbour, j
        logical :: intersects
        type(mesh_type), pointer :: mesh_B
        real, dimension(size(posA, 1), 2) :: bboxA
        integer :: ele_B
        type(integer_set) :: in_list
        type(integer_hash_table) :: possibles_tbl
        integer :: possible_size

        bboxA = bbox(posA)
        call allocate(in_list)
        call allocate(possibles_tbl)
        possible_size = 0

        mesh_B => positionsB%mesh

        do while (clues%length /= 0)
          ele_B = pop(clues)
          if (.not. has_value(in_list, ele_B)) then
            call insert(map, ele_B)
            call insert(in_list, ele_B)
          end if

          ! Append all the neighbours of ele_B to possibles. 
          neigh_B => row_m_ptr(eelist_B, ele_B)
          do i=1,size(neigh_B)
            neighbour = neigh_B(i)
            if (neighbour <= 0) cycle
            if (.not. has_value(in_list, neighbour)) then
              possible_size = possible_size + 1
              call insert(possibles_tbl, possible_size, neighbour)
              call insert(in_list, neighbour)
            end if
          end do
        end do

        ! while len(possibles) != 0:
          ! If predicate(ele_A, ele_B) is false: remove it from possibles and add it to rejects.
          ! If true: add it to map and add all its neighbours not in map or rejects to map.

        j = 1
        do while (j <= possible_size)
          possible = fetch(possibles_tbl, j)
          intersects = bbox_predicate(bboxA, bboxes_B(possible, :, :))
          if (intersects) then
            call insert(map, possible)
            neigh_B => row_m_ptr(eelist_B, possible)
            do i=1,size(neigh_B)
              neighbour = neigh_B(i)
              if (neighbour <= 0) cycle
              if (.not. has_value(in_list, neighbour)) then
                possible_size = possible_size + 1
                call insert(possibles_tbl, possible_size, neighbour)
                call insert(in_list, neighbour)
              end if
            end do
          end if
          j = j + 1
        end do

        call deallocate(in_list)
        call deallocate(possibles_tbl)

        possible_size = 0
      end function advance_front
  end function advancing_front_intersection_finder
  
end module
